// 1、介绍下log平台
//        我们的app都是采用混合开发的形式，flutter内嵌h5，我们的h5是有vconsole这种日志调试工具的，无论是我们开发，还是产品和测试验收时候，
//    查看日志来查找问题都是很方便的；但是在flutter端，我们并没有这种实时查看日志的工具，为了让flutter也拥有类似于vconsole调试日志你的便捷性，
//    我们为flutter端开发也开发出类似于vconsole的日志调试工具，可以实时查看日志和接口，但因为在app上查看页面比较小，而且想要复制日志或者接口信息
//    也比较不方便，所以我们开发了pc端同时也可以内嵌在app中使用；如果flutter端使用我们的调试工具，h5依然使用vconsole的话，在app运行时，
//    需要来回切换调试工具来查看日志，所以我们为h5也接入了日志平台，实现日志调试一体化。
//        平台实现的过程呢，首先flutter端会内嵌一个插件来起一个websocket服务，同时我负责的显示日志的页面会作为websocket的客户端来连接这个服务，
//    flutter插件把在代码中捕获到的日志，通过socket连接推给页面的客户端，客户端接收日志显示在页面上。接下来我们的h5代码中也会内嵌一个vite插件，
//    在插件中连接flutter插件的websocket服务，把代码中捕获到的日志和接口信息通过socket连接推送给flutter插件的socket服务，服务接收到日志后，
//    依然按照原流程处理日志并显示。
//        难点呢就是，随着我们app的运行，页面上的日志是不断追加的，可能会出现成千上万条日志，页面会出现切换tab和滚动时候卡顿问题，最后我们采用懒加载
//    解决tab切换卡顿，通过虚拟滚动解决滚动卡顿问题。
// 2、从开发体验和测试验收体验的角度，具体说说 log 平台是如何提升这两方面体验的？
//        1、代码侵入性低，拿h5举例，我们是直接重写console对象上的方法，将接收到的参数都传给socket来显示，用户在开发代码过程并没有任何影响；
//        2、对于h5来说，只需要在vite的plugins属性中，多安装一个插件即可；
//        3、减少测试验收中查找问题步骤，之前是测试过程中有问题，找开发启动代码复现、看日志、找问题，现在是测试发现问题，直接查看日志，如果是代码问题再找开发解决；

// 3、开发一个vite插件的流程
//        1、初始化一个项目，在项目中创建一个ts文件；
//        2、ts文件中返回一个对象，对象中包含插件的钩子；
//        3、执行npm publish命令发布插件；
//        4、在业务代码中引入。
// 4、vite插件都有哪些钩子？
//            generateBundle：在生成最终打包文件之前调用，可以用来修改打包后的内容。
//        通用钩子：
//            buildStart：1、构建开始时候调用；2、可用于执行一些初始化操作，比如创建临时目录、清除缓存等；
//            resolveId: 1、模块解析阶段执行，比如遇到一个import 'loadsh'，需要将'loadsh'解析为实际文件路径时期执行；
//                       2、自定义模块解析逻辑、处理外部模块（将一些依赖运行从外部加载）、拦截一些模块的解析过程并对其修改、实现动态解析；
//            load: 1、在vite解析到一个需要处理的模块路径时，先调用load，让插件可以提供模块内容，如果所有的load都返回null或undefined，就
//                     从文件中读取内容；
//                  2、拦截模块加载从而直接提供内容、读取一些从其他数据源比如数据库、网络等加载的数据源、对模块原始内容预处理（添加通用代码、替换字符串等）
//            transform：1、在模块加载完成，执行其他操作之前调用，例如加载完模块后调用钩子，可以对加载的内容进行修改并返回新内容；
//                       2、代码转换，比如将代码从ts转换为js、jsx转换为js等、注入代码，比如添加全局变量等、代码优化，例如压缩代码等、自定义处理逻辑，比如针对特定格式文件特殊处理；
//            buildEnd：1、构建结束时候调用，也就是在完成所有模块的解析、转换、打包等并且生成最终产物时候调用；
//                      2、资源清理，构建过程中可能会创建临时文件或占用系统资源，可以在这时候清理掉；构建后处理，对构建后的产物做一些处理；
//                         错误处理和日志记录，构建过程中出现错误，可以在这时候捕获；通知外部系统；
//            closeBundle：1、整个打包过程已经结束，并且输出文件都已经生成和写入磁盘后进行；
//                         2、对最终产物二次处理；生成额外的构建产物或报告；释放资源和清理临时文件；将构建产物上传到服务器、触发部署操作等；
//        vite独有的钩子：
//            config：1、在 Vite 解析配置文件（如 vite.config.js 或 vite.config.ts）之前被调用
//                    2、修改默认配置、 根据环境变量动态配置、注入额外的插件或配置项、条件性地启用或禁用某些配置
//            configResolved：在 Vite 完成所有配置解析之后调用。使用这个钩子读取和存储最终解析的配置。当插件需要根据运行的命令做一些不同的事情时，它也很有用。
//            configureServer：是用于配置开发服务器的钩子
//            configurePreviewServer：是用于配置预览服务器的钩子
//            transformIndexHtml：转换 index.html 的专用钩子。钩子接收当前的 HTML 字符串和转换上下文
//            handleHotUpdate：执行自定义 HMR 更新处理
//    插件的执行顺序：
//        1、在vite.config的plugin钩子中，按顺序执行；
//        2、每个vite插件可以额外指定一个enforce属性来调整它的应用顺序，值为pre和post。pre表示在vite的核心插件执行之前执行，post表示在核心插件执行之后执行，核心插件就是一些
//    比如vite自身内置的、用于完成基础构建任务，像模块解析、转化等都是核心插件。
//        解析后的插件将按照以下顺序排列：
//            1、Alias、(因为Alias没有自定义钩子函数和复杂逻辑处理，所以不是传统意义上的插件，而是vite内置的一个基础功能，只需要通过配置就可以实现；但是为什么会在执行顺序描述中出现，是因为
//        模块解析在构建过程中是非常重要而且关键的，而模块解析又需要先处理别名，所以在顺序描述中增加Alias，可以比较清晰的了解各个环节执行顺序。)
//            2、带有 enforce: 'pre' 的用户插件、
//            3、Vite 核心插件、没有 enforce 值的用户插件交替执行，按照钩子函数顺序执行
//            (现在有两个没有enfore值的插件a和b，并且两个插件都定一个config钩子函数，如果核心插件也有config函数，会先执行核心插件的copfig，再按照a和b在plugins中的顺序执行a和b的config)
//            (比如我们在核心插件的transform钩子中将css文件的相对路径做了转换，插件a中要对转换后的css压缩，如果等核心插件全部执行完可能其他钩子又对css做了其他处理，我们在a中压缩的就不是
//        最初转换后的css，想要实现对最初的css压缩，还要利用各种方法例如缓存啊等，去记录转换后的css，拿如果我们执行完核心插件的transform直接开始执行a的transform，就可以提高处理效率、
//        减小处理开销、避免代码冲突；
//            4、Vite 构建用的插件(一版指的是在核心插件和无enfore值的插件执行完后，继续与构建相关的操作，比如资源合并、代码分割等，例如vite内置插件esbuild)
//            5、带有 enforce: 'post' 的用户插件、Vite 后置构建插件（最小化，manifest，报告）
//        默认情况下插件在开发（serve）和构建（build）模式中都会调用。如果插件只需要在预览或构建期间有条件地应用，请使用 apply 属性指明它们仅在 'build' 或 'serve' 模式时调用
// 5、在 Flutter 端内嵌插件起 Websocket 服务，为什么选择 Websocket 这种通信方式？它相对于其他通信方式（如 HTTP 轮询等）有什么优势？
//        1、websocket建立的是全双工通信连接，客户端和服务端都可以向对方发送数据，而http轮询是客户端在一定时间间隔向服务端发送请求获取数据，相比较之下websocket实时性比较高，因为websocket
//    在建立连接后，可以实时向对方推送数据，而http轮询的时间间隔设置大了，消息不够实时，小了，又会因为频繁发送请求对服务器造成负担；
//        2、wensocket在建立连接时候会有一次握手，之后就一直处于连接状态，而http轮询每次请求都需要发送完整http请求和响应，包含大量头部信息，并且不断发起请求，会对性能造成压力；
//        3、websocket只需要连接一次，不需要为每次传输都分配新资源，而http轮询每次都需要发起请求，每次都需要分配新资源，对比websocket可以减少资源占用。
// 6、Websocket 服务在处理大量日志推送时，如何保证稳定性和性能？有没有遇到过网络波动等问题，是如何解决的？
//        断开自动重连、补发断开时候未发送成功的日志
// 7、H5 端的日志和接口信息是如何与 Flutter 端的日志系统进行整合的？如何保证两者之间数据传输的稳定性和准确性？
//        h5端在vite插件中，连接flutter在插件中起的websocket服务，然后把捕获到的日志和接口信息发送给服务，服务将接收到的日志和自己捕获到的日志一起发送到显示页面的websocket客户端上并显示；
// 8、在 Websocket 通信过程中，如何处理网络波动、连接中断等异常情况？有没有相应的重试机制或恢复策略？
//        针对这种情况，其实socket.io框架都可以帮我们处理，但是因为我是后面接入的，我们app端同学最开始做的时候已经选用了websocket，所以我们就只能在websocket之上想办法封装，对于网络连接正常断开，
//    或则和服务器主动关闭这种情况我们是可以监听到事件的，我们直接重连即可，但是对于比如我们起的服务发生故障、崩溃或者内部错误，服务器还没来得及给我们发送信号，所以监听不到，对于这种情况，
//    我们采用心跳检测的方式，每隔30秒客户端向服务器发送一个数据ping字符串，服务器收到后回应一个响应数据pong字符串，如果客户端在3个30秒之内收到pong说明连接正常，否则说明连接已经断开了，
//    然后立即开始尝试重连，重连三次如果依然失败，就直接关闭并且提示用户日志连接已经断开，检查下网络等等；
//        我们不光是把日志推到页面上显示，还会把日志存到文件中，在文件tab中显示文件list，用户除了在页面上查看日志，还可以通过文件来查找，所以如果我们的socket连接断开，页面上没有及时显示日志时候，
//    我们可以到日志文件中查找日志。
//        对于日志平台的使用，我们对日志流量进行监控，计算每分钟产生日志的字节数，我们在将日志平台接入项目的时候，会提供一个每分钟最大字节数的参数给用户，如果计算出来的字节数大于这个阈值，
//    就弹窗提示，给用户预警，预警弹窗不会阻断平台的使用，可以关掉弹窗继续使用。
// 8、介绍下项目亮点
//        实现日志调试一体化、创新的日志传输与展示方案、性能优化措施有效、满足多场景使用需求
// 9、为什么将逻辑写在closeBundle钩子函数中，写在其他钩子中可行吗？
//        在这个钩子中，整个构建过程即将结束，这时候所有的模块都已经被处理、打包和优化完成，在这个阶段捕获日志，可以保证日志中包含了关于整个构建过程的完整信息，包括所有模块的处理结果、依赖关系等，
//    可以确保不会因为资源不完整导致日志不完整；而且在早期钩子中处理，会影响很干扰其他构建流程，在closeBundle中，我们可以一次性获取到关于整个构建过程的各种信息，便于分析调试。
//        放在其他钩子中，例如transform，代码侵入性太强了，会修改源码，肯定就会对源码原逻辑造成影响，而且每次模块转换都调用，会增加额外日志开销，此外不同js环境对console.log支持也不一样，可能会有兼容性问题。
// 10、除了懒加载、虚拟滚动，工作中还做过哪些优化，举个例子说明？
//        