// 1、介绍下log平台
//        我们的app都是采用混合开发的形式，flutter内嵌h5，我们的h5是有vconsole这种日志调试工具的，无论是我们开发，还是产品和测试验收时候，
//    查看日志来查找问题都是很方便的；但是在flutter端，我们并没有这种实时查看日志的工具，为了让flutter也拥有类似于vconsole调试日志你的便捷性，
//    我们为flutter端开发也开发出类似于vconsole的日志调试工具，可以实时查看日志和接口，但因为在app上查看页面比较小，而且想要复制日志或者接口信息
//    也比较不方便，所以我们开发了pc端同时也可以内嵌在app中使用；如果flutter端使用我们的调试工具，h5依然使用vconsole的话，在app运行时，
//    需要来回切换调试工具来查看日志，所以我们为h5也接入了日志平台，实现日志调试一体化。
//        平台实现的过程呢，首先flutter端会内嵌一个插件来起一个websocket服务，同时我负责的显示日志的页面会作为websocket的客户端来连接这个服务，
//    flutter插件把在代码中捕获到的日志，通过socket连接推给页面的客户端，客户端接收日志显示在页面上。接下来我们的h5代码中也会内嵌一个vite插件，
//    在插件中连接flutter插件的websocket服务，把代码中捕获到的日志和接口信息通过socket连接推送给flutter插件的socket服务，服务接收到日志后，
//    依然按照原流程处理日志并显示。
//        难点呢就是，随着我们app的运行，页面上的日志是不断追加的，可能会出现成千上万条日志，页面会出现切换tab和滚动时候卡顿问题，最后我们采用懒加载
//    解决tab切换卡顿，通过虚拟滚动解决滚动卡顿问题。
// 2、从开发体验和测试验收体验的角度，具体说说 log 平台是如何提升这两方面体验的？
//        1、代码侵入性低，拿h5举例，我们是直接重写console对象上的方法，将接收到的参数都传给socket来显示，用户在开发代码过程并没有任何影响；
//        2、对于h5来说，只需要在vite的plugins属性中，多安装一个插件即可；
//        3、减少测试验收中查找问题步骤，之前是测试过程中有问题，找开发启动代码复现、看日志、找问题，现在是测试发现问题，直接查看日志，如果是代码问题再找开发解决；

// 3、开发一个vite插件的流程
//        1、初始化一个项目，在项目中创建一个ts文件；
//        2、ts文件中返回一个对象，对象中包含插件的钩子；
//        3、执行npm publish命令发布插件；
//        4、在业务代码中引入。
// 4、vite插件都有哪些钩子？
//        通用钩子：
//            buildStart：1、构建开始时候调用；2、可用于执行一些初始化操作，比如创建临时目录、清除缓存等；
//            resolveId: 1、模块解析阶段执行，比如遇到一个import 'loadsh'，需要将'loadsh'解析为实际文件路径时期执行；
//                       2、自定义模块解析逻辑、处理外部模块（将一些依赖运行从外部加载）、拦截一些模块的解析过程并对其修改、实现动态解析；
//            load: 1、在vite解析到一个需要处理的模块路径时，先调用load，让插件可以提供模块内容，如果所有的load都返回null或undefined，就
//                     从文件中读取内容；
//                  2、拦截模块加载从而直接提供内容、读取一些从其他数据源比如数据库、网络等加载的数据源、对模块原始内容预处理（添加通用代码、替换字符串等）
//            transform：1、在模块加载完成，执行其他操作之前调用，例如加载完模块后调用钩子，可以对加载的内容进行修改并返回新内容；
//                       2、代码转换，比如将代码从ts转换为js、jsx转换为js等、注入代码，比如添加全局变量等、代码优化，例如压缩代码等、自定义处理逻辑，比如针对特定格式文件特殊处理；
//            buildEnd：1、构建结束时候调用，也就是在完成所有模块的解析、转换、打包等并且生成最终产物时候调用；
//                      2、资源清理，构建过程中可能会创建临时文件或占用系统资源，可以在这时候清理掉；构建后处理，对构建后的产物做一些处理；
//                         错误处理和日志记录，构建过程中出现错误，可以在这时候捕获；通知外部系统；
//            closeBundle：1、整个打包过程已经结束，并且输出文件都已经生成和写入磁盘后进行；
//                         2、对最终产物二次处理；生成额外的构建产物或报告；释放资源和清理临时文件；将构建产物上传到服务器、触发部署操作等；
//        vite独有的钩子：
//            config：1、在 Vite 解析配置文件（如 vite.config.js 或 vite.config.ts）之前被调用
//                    2、修改默认配置、 根据环境变量动态配置、注入额外的插件或配置项、条件性地启用或禁用某些配置
//            configResolved：在解析 Vite 配置后调用。使用这个钩子读取和存储最终解析的配置。当插件需要根据运行的命令做一些不同的事情时，它也很有用。
//            configureServer：是用于配置开发服务器的钩子
//            configurePreviewServer：是用于配置预览服务器的钩子
//            transformIndexHtml：转换 index.html 的专用钩子。钩子接收当前的 HTML 字符串和转换上下文
//            handleHotUpdate：执行自定义 HMR 更新处理
//    插件的执行顺序：
//        一个 Vite 插件可以额外指定一个 enforce 属性（类似于 webpack 加载器）来调整它的应用顺序。enforce 的值可以是pre 或 post。
//        解析后的插件将按照以下顺序排列：Alias、带有 enforce: 'pre' 的用户插件、Vite 核心插件、没有 enforce 值的用户插件、Vite 构建用的插件、
//                                     带有 enforce: 'post' 的用户插件、Vite 后置构建插件（最小化，manifest，报告）
//        默认情况下插件在开发（serve）和构建（build）模式中都会调用。如果插件只需要在预览或构建期间有条件地应用，请使用 apply 属性指明它们仅在 'build' 或 'serve' 模式时调用