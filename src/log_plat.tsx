// 1、介绍下log平台
//        我们的app都是采用混合开发的形式，flutter内嵌h5，我们的h5是有vconsole这种日志调试工具的，无论是我们开发，还是产品和测试验收时候，
//    查看日志来查找问题都是很方便的；但是在flutter端，我们并没有这种实时查看日志的工具，为了让flutter也拥有类似于vconsole调试日志你的便捷性，
//    我们为flutter端开发也开发出类似于vconsole的日志调试工具，可以实时查看日志和接口，但因为在app上查看页面比较小，而且想要复制日志或者接口信息
//    也比较不方便，所以我们开发了pc端同时也可以内嵌在app中使用；如果flutter端使用我们的调试工具，h5依然使用vconsole的话，在app运行时，
//    需要来回切换调试工具来查看日志，所以我们为h5也接入了日志平台，实现日志调试一体化。
//        平台实现的过程呢，首先flutter端会内嵌一个插件来起一个websocket服务，同时我负责的显示日志的页面会作为websocket的客户端来连接这个服务，
//    flutter插件把在代码中捕获到的日志，通过socket连接推给页面的客户端，客户端接收日志显示在页面上。接下来我们的h5代码中也会内嵌一个vite插件，
//    在插件中连接flutter插件的websocket服务，把代码中捕获到的日志和接口信息通过socket连接推送给flutter插件的socket服务，服务接收到日志后，
//    依然按照原流程处理日志并显示。
//        难点呢就是，随着我们app的运行，页面上的日志是不断追加的，可能会出现成千上万条日志，页面会出现切换tab和滚动时候卡顿问题，最后我们采用懒加载
//    解决tab切换卡顿，通过虚拟滚动解决滚动卡顿问题。
// 2、从开发体验和测试验收体验的角度，具体说说 log 平台是如何提升这两方面体验的？
//        1、代码侵入性低，拿h5举例，我们是直接重写console对象上的方法，将接收到的参数都传给socket来显示，用户在开发代码过程并没有任何影响；
//        2、对于h5来说，只需要在vite的plugins属性中，多安装一个插件即可；
//        3、减少测试验收中查找问题步骤，之前是测试过程中有问题，找开发启动代码复现、看日志、找问题，现在是测试发现问题，直接查看日志，如果是代码问题再找开发解决；

// 3、开发一个vite插件的流程
//        1、初始化一个项目，在项目中创建一个ts文件；
//        2、ts文件中返回一个对象，对象中包含插件的钩子；
//        3、执行npm publish命令发布插件；
//        4、在业务代码中引入。
// 4、vite插件都有哪些钩子？
//            generateBundle：在生成最终打包文件之前调用，可以用来修改打包后的内容。
//        通用钩子：
//            buildStart：1、构建开始时候调用；2、可用于执行一些初始化操作，比如创建临时目录、清除缓存等；
//            resolveId: 1、模块解析阶段执行，比如遇到一个import 'loadsh'，需要将'loadsh'解析为实际文件路径时期执行；
//                       2、自定义模块解析逻辑、处理外部模块（将一些依赖运行从外部加载）、拦截一些模块的解析过程并对其修改、实现动态解析；
//            load: 1、在vite解析到一个需要处理的模块路径时，先调用load，让插件可以提供模块内容，如果所有的load都返回null或undefined，就
//                     从文件中读取内容；
//                  2、拦截模块加载从而直接提供内容、读取一些从其他数据源比如数据库、网络等加载的数据源、对模块原始内容预处理（添加通用代码、替换字符串等）
//            transform：1、在模块加载完成，执行其他操作之前调用，例如加载完模块后调用钩子，可以对加载的内容进行修改并返回新内容；
//                       2、代码转换，比如将代码从ts转换为js、jsx转换为js等、注入代码，比如添加全局变量等、代码优化，例如压缩代码等、自定义处理逻辑，比如针对特定格式文件特殊处理；
//            buildEnd：1、构建结束时候调用，也就是在完成所有模块的解析、转换、打包等并且生成最终产物时候调用；
//                      2、资源清理，构建过程中可能会创建临时文件或占用系统资源，可以在这时候清理掉；构建后处理，对构建后的产物做一些处理；
//                         错误处理和日志记录，构建过程中出现错误，可以在这时候捕获；通知外部系统；
//            closeBundle：1、整个打包过程已经结束，并且输出文件都已经生成和写入磁盘后进行；
//                         2、对最终产物二次处理；生成额外的构建产物或报告；释放资源和清理临时文件；将构建产物上传到服务器、触发部署操作等；
//        vite独有的钩子：
//            config：1、在 Vite 解析配置文件（如 vite.config.js 或 vite.config.ts）之前被调用
//                    2、修改默认配置、 根据环境变量动态配置、注入额外的插件或配置项、条件性地启用或禁用某些配置
//            configResolved：在 Vite 完成所有配置解析之后调用。使用这个钩子读取和存储最终解析的配置。当插件需要根据运行的命令做一些不同的事情时，它也很有用。
//            configureServer：是用于配置开发服务器的钩子
//            configurePreviewServer：是用于配置预览服务器的钩子
//            transformIndexHtml：转换 index.html 的专用钩子。钩子接收当前的 HTML 字符串和转换上下文
//            handleHotUpdate：执行自定义 HMR 更新处理
//    插件的执行顺序：
//        1、在vite.config的plugin钩子中，按顺序执行；
//        2、每个vite插件可以额外指定一个enforce属性来调整它的应用顺序，值为pre和post。pre表示在vite的核心插件执行之前执行，post表示在核心插件执行之后执行，核心插件就是一些
//    比如vite自身内置的、用于完成基础构建任务，像模块解析、转化等都是核心插件。
//        解析后的插件将按照以下顺序排列：
//            1、Alias、(因为Alias没有自定义钩子函数和复杂逻辑处理，所以不是传统意义上的插件，而是vite内置的一个基础功能，只需要通过配置就可以实现；但是为什么会在执行顺序描述中出现，是因为
//        模块解析在构建过程中是非常重要而且关键的，而模块解析又需要先处理别名，所以在顺序描述中增加Alias，可以比较清晰的了解各个环节执行顺序。)
//            2、带有 enforce: 'pre' 的用户插件、
//            3、Vite 核心插件、没有 enforce 值的用户插件交替执行，按照钩子函数顺序执行
//            (现在有两个没有enfore值的插件a和b，并且两个插件都定一个config钩子函数，如果核心插件也有config函数，会先执行核心插件的copfig，再按照a和b在plugins中的顺序执行a和b的config)
//            (比如我们在核心插件的transform钩子中将css文件的相对路径做了转换，插件a中要对转换后的css压缩，如果等核心插件全部执行完可能其他钩子又对css做了其他处理，我们在a中压缩的就不是
//        最初转换后的css，想要实现对最初的css压缩，还要利用各种方法例如缓存啊等，去记录转换后的css，拿如果我们执行完核心插件的transform直接开始执行a的transform，就可以提高处理效率、
//        减小处理开销、避免代码冲突；
//            4、Vite 构建用的插件(一版指的是在核心插件和无enfore值的插件执行完后，继续与构建相关的操作，比如资源合并、代码分割等，例如vite内置插件esbuild)
//            5、带有 enforce: 'post' 的用户插件、Vite 后置构建插件（最小化，manifest，报告）
//        默认情况下插件在开发（serve）和构建（build）模式中都会调用。如果插件只需要在预览或构建期间有条件地应用，请使用 apply 属性指明它们仅在 'build' 或 'serve' 模式时调用
// 5、在 Flutter 端内嵌插件起 Websocket 服务，为什么选择 Websocket 这种通信方式？它相对于其他通信方式（如 HTTP 轮询等）有什么优势？
//        1、websocket建立的是全双工通信连接，客户端和服务端都可以向对方发送数据，而http轮询是客户端在一定时间间隔向服务端发送请求获取数据，相比较之下websocket实时性比较高，因为websocket
//    在建立连接后，可以实时向对方推送数据，而http轮询的时间间隔设置大了，消息不够实时，小了，又会因为频繁发送请求对服务器造成负担；
//        2、wensocket在建立连接时候会有一次握手，之后就一直处于连接状态，而http轮询每次请求都需要发送完整http请求和响应，包含大量头部信息，并且不断发起请求，会对性能造成压力；
//        3、websocket只需要连接一次，不需要为每次传输都分配新资源，而http轮询每次都需要发起请求，每次都需要分配新资源，对比websocket可以减少资源占用。
// 6、Websocket 服务在处理大量日志推送时，如何保证稳定性和性能？有没有遇到过网络波动等问题，是如何解决的？
//        断开自动重连、补发断开时候未发送成功的日志
// 7、H5 端的日志和接口信息是如何与 Flutter 端的日志系统进行整合的？如何保证两者之间数据传输的稳定性和准确性？
//        h5端在vite插件中，连接flutter在插件中起的websocket服务，然后把捕获到的日志和接口信息发送给服务，服务将接收到的日志和自己捕获到的日志一起发送到显示页面的websocket客户端上并显示；
// 8、在 Websocket 通信过程中，如何处理网络波动、连接中断等异常情况？有没有相应的重试机制或恢复策略？
//        针对这种情况，其实socket.io框架都可以帮我们处理，但是因为我是后面接入的，我们app端同学最开始做的时候已经选用了websocket，所以我们就只能在websocket之上想办法封装，对于网络连接正常断开，
//    或则和服务器主动关闭这种情况我们是可以监听到事件的，我们直接重连即可，但是对于比如我们起的服务发生故障、崩溃或者内部错误，服务器还没来得及给我们发送信号，所以监听不到，对于这种情况，
//    我们采用心跳检测的方式，每隔30秒客户端向服务器发送一个数据ping字符串，服务器收到后回应一个响应数据pong字符串，如果客户端在3个30秒之内收到pong说明连接正常，否则说明连接已经断开了，
//    然后立即开始尝试重连，重连三次如果依然失败，就直接关闭并且提示用户日志连接已经断开，检查下网络等等；
//        我们不光是把日志推到页面上显示，还会把日志存到文件中，在文件tab中显示文件list，用户除了在页面上查看日志，还可以通过文件来查找，所以如果我们的socket连接断开，页面上没有及时显示日志时候，
//    我们可以到日志文件中查找日志。
//        对于日志平台的使用，我们对日志流量进行监控，计算每分钟产生日志的字节数，我们在将日志平台接入项目的时候，会提供一个每分钟最大字节数的参数给用户，如果计算出来的字节数大于这个阈值，
//    就弹窗提示，给用户预警，预警弹窗不会阻断平台的使用，可以关掉弹窗继续使用。
// 8、介绍下项目亮点
//        实现日志调试一体化、创新的日志传输与展示方案、性能优化措施有效、满足多场景使用需求
// 9、为什么将逻辑写在closeBundle钩子函数中，写在其他钩子中可行吗？
//        在这个钩子中，整个构建过程即将结束，这时候所有的模块都已经被处理、打包和优化完成，在这个阶段捕获日志，可以保证日志中包含了关于整个构建过程的完整信息，包括所有模块的处理结果、依赖关系等，
//    可以确保不会因为资源不完整导致日志不完整；而且在早期钩子中处理，会影响很干扰其他构建流程，在closeBundle中，我们可以一次性获取到关于整个构建过程的各种信息，便于分析调试。
//        放在其他钩子中，例如transform，代码侵入性太强了，会修改源码，肯定就会对源码原逻辑造成影响，而且每次模块转换都调用，会增加额外日志开销，此外不同js环境对console.log支持也不一样，可能会有兼容性问题。
// 10、除了懒加载、虚拟滚动，工作中还做过哪些优化，举个例子说明？
//        
// 11、捕获接口信息的具体过程？
//        我们利用Proxy对window.XMLHttpRequest做了代理。
//        首先定义一个XHRProxy类，类中定义了一个static方法create，调用create方法可以返回一个Proxy实例，Proxy实例对原生的XMLHttpRequest进行了监听，在执行实例化XMLHttpRequest操作时，
//    会返回一个新的Proxy实例，新的Proxy实例同样对原生XMLHttpRequest进行了监听，这次监听的时XMLHttpRequest的具体行为，例如open、send、setRequestHeader等，一旦调用XMLHttpRequest的
//    这些属性或者执行这些方法，就会触发我们自定义的拦截行为，会将我们需要的请求和响应的具体信息处理成我们想要的格式，并执行回调函数，发送给app的socket服务上。

// 12、什么是Proxy，作用以及工作原理？
//        1、Proxy也就是代理，是js的一个内置对象，使用Proxy包裹要被代理的对象，相当于在对象之前架了一个拦截器，我们可以使用Proxy，在对目标对象进行读取、复制等一系列操作时，做一些自定义操作，能增强代码的灵活性和可维护性；
//        2、一般采用new Proxy(target， handler)的方式使用，new Proxy返回的是一个包含了我们自定义拦截行为的新对象，在触发拦截行为时候就会执行我们的自定义操作，
//    target只能是对象类型，任意对象，例如函数、对象、Proxy对象等都可以，handler可以捕获get、set、has等13种object的内部方法，并在方法中自定义行为，在对proxy对象触发这些操作时，就执行自定义方法；
//        3、比如有一个对象obj={a:{b: 1}, c: 2}，使用Proxy包裹obj，只有obj会被代理，obj.a不会被代理，我们可以使用递归来深度代理；
//        4、对于有this归属问题的对象，Proxy代理可能会有问题，比如Class obj1{construct() {} getName() {return this.name}}，使用Proxy代理obj2=new obj1()，proxy.name=1，访问getName会拿不到值，因为此时this指向obj1，
//    如果使用Proxy代理obj1，再执行obj2.name=2，此时就可以再访问getName就可以拿到值2；
//        5、当对Proxy对象进行操作时，js引擎会首先检查handler对象中是否定义了相应的拦截方法，如果定义了，就把对象和属性等传入，执行我们的自定义方法，我们可以在其中自定义行为实现对属性的拦截；
//        6、可以使用const {proxy, revoke} = Proxy.revocable(target, handler)来创建可以撤销的代理，proxy是代理对象，revoke是函数，执行revoke会撤销proxy的代理，执行完函数，再调用proxy.message，会抛出异常；
//        7、
//        8、es标准委员会未Object定义了14个内部方法，例如get、set、HasProperty、GetPrototypeOf等，使用Proxy代理Object，handler可以捕获这些方法并重写
//        举例：
//            1、vue3实现对对象的观察者模式，就是利用Proxy+依赖收集和更新实现的;
//            2、自己工作中用到的：接口信息的捕获；
//        9、Proxy 与 Object.defineProperty() 相比，有哪些优势
//              1、可拦截的操作更全面：Proxy 可以拦截对象的多种操作，如属性访问、赋值、函数调用、in 操作符、delete 操作符等，而 Object.defineProperty() 主要用于拦截属性的 get 和 set 操作。
//              2、对数组的支持更好：Proxy 可以方便地拦截数组的各种操作，如元素的添加、删除、修改等，而使用 Object.defineProperty() 处理数组时会有一些局限性。
//                     对数组的局限性：
//                          1、Object.defineProperty() 是基于属性进行劫持的，它需要明确知道要劫持的属性名。对于数组来说，元素的索引就是属性名，使用数组方法，例如push时候，没有访问索引，所以无法感知到变化；
//                          2、因为数组的length是动态变化的，数组的长度变化会影响元素的访问和删除，处理起来比较复杂；
//              3、可以拦截对象的新增属性：Proxy 可以拦截对象新增属性的操作，而 Object.defineProperty() 只能对已存在的属性进行拦截，对新增属性拦截，需要额外代码处理。

// 13、介绍下Reflect？
//         1、顾名思义，Reflect就是反射，我们在操作对象的时候，使用对象的内部方法，例如Object.defineProperty()、Object.getOwnPropertyDescriptor()是函数形式调用的，delete、in是操作符形式调用的等，比较分散，也不够简洁明了，
//     有些方法行为也不够规范，为了解决这些i行为，es6引入了Reflect，将Object上的方法都映射到了Reflect上，而且后面还会继续往Reflect上添加新的方法；
//         2、使用Reflect调用Object内部方法，例如Reflect.get()、Reflect.set()、Reflect.has()、Reflect.deleteProperty()等，简洁明了，并且方法执行出错时候会返回false或者undefined，不会抛出异常，使用比较安全；
//     像Object.defineProperty()执行失败会抛出异常，delete、Object.assign不会有成功失败反馈，需要对这些方法进行统一规范的管理；
//         3、Reflect可以和Proxy结合使用，在Proxy的handler中捕获例如get方法时候，除了加入自定义逻辑，还需要执行默认逻辑，这时候就可以使用Reflect.get来执行默认逻辑；
//               举例：
//                   const handler = {
//                           get(target, prop) {
//                              let current = target;
//                              while (current) {
//                                  if (Object.prototype.hasOwnProperty.call(current, prop)) {
//                                        return current[prop];
//                                   }
//                                  current = Object.getPrototypeOf(current);
//                               }
//                              return undefined;
//                            }}
//                  使用Reflect改善：
//                      const handler = {
//                             get(target, prop) {
//                                 return Reflect.get(target, prop);
//                             }
//                      };
//        4、Reflect.get 方法在查找属性时的具体流程是怎样的
//                Reflect.get 首先会检查目标对象自身是否存在指定的属性。如果存在，就返回该属性的值；若不存在，则会沿着原型链向上查找，直到找到该属性或者到达原型链的末尾（即 Object.prototype）。
//        若整个原型链都没有该属性，则返回 undefined。此外，如果提供了第三个参数 receiver，当属性是 getter 时，getter 函数中的 this 值会被设置为 receiver
//        5、在 Proxy 的拦截器中使用 Reflect 有什么好处
//                在 Proxy 拦截对象操作时，使用 Reflect 可以避免手动实现对象操作的默认行为。例如在拦截属性访问时，手动实现需要处理原型链查找等复杂逻辑，而使用 Reflect.get 可以简洁地实现默认的属性查找行为。
//        同时，Reflect 的方法与 Proxy 的拦截方法一一对应，保证了代码的一致性和规范性，提高了代码的可读性和可维护性。
//        6、Reflect 与 Object 对象的方法有什么区别和联系
//             联系在于它们都与对象操作相关；
//             区别主要体现在：Reflect 提供的是更统一、函数式的对象操作方法，而 Object 的方法更侧重于对象的创建、原型操作等方面。Reflect 的方法在操作失败时返回 false 或 undefined，而 Object 的一些方法可能会抛出错误。
//        另外，Reflect 与 Proxy 紧密配合，用于实现对象操作的拦截和默认行为的调用，Object 则没有这方面的直接关联。