// 1、vite的热更新原理
//        1、开发服务器启动
//               当我们执行vite命令启动开发服务器时，vite会从入口文件出发，解析各模块，记录各模块之间的依赖关系，构建一个模块图；
//        2、客户端与服务器建立websocket连接
//               在浏览器加载页面时，vite会在客户端注入一段脚本用来处理热更新，脚本中建立了一个客户端与我们启动的服务器的websocket连接，保证客户端和websocket可以实时通信；
//        3、文件变更监听、模块更新检测、生成更新补丁
//               vite会使用文件系统监听工具例如chokidar来监控项目中文件的变化，当检测到文件变化时，vite会重新解析变化的文件，与之前构建的模块图对比，如果内容发生了变化，
//           vite会确定受影响的模块以及这些模块的依赖关系，根据模块变化情况生成更新补丁，补丁包含了需要更新模块的新代码以及相关元信息，如模块ID、依赖关系等；
//        4、通过websocket发送更新补丁、客户端更新模块
//               服务器会通过websocket连接将更新补丁推送到客户端，客户端热更新脚本接收补丁后，根据补丁中信息找到需要更新的模块，然后使用import动态导入功能加载新模块，并替换旧模块；
//        5、执行热更新钩子
//               完成模块替换后，vite会执行一些热更新钩子函数，可以在热更新之后做一些回调操作。例如import.meta.hot.accept(() => {})

// 2、vite预构建
//        vite预构建主要是在开发服务器启动时候，针对我们代码中引入的第三方依赖和库加载和性能问题进行处理，包括依赖扫描、格式转换、打包、缓存等步骤；
//        具体工作原理：
//            1、首先，vite会从项目的入口文件，例如index.html、main.js等出发，不执行代码，而是通过import递归的分析项目中的每个间接和直接依赖以及依赖的依赖，形成一个完成的依赖图，图中包含了
//               依赖的模块信息，以及模块之间的依赖关系；
//            2、因为很多第三方库都是用commonjs或者UMD格式发布的，所以vite在形成依赖图之后，会检查依赖的格式，然后利用esbuild将非es格式转换为es格式；
//            3、vite默认会将node_modules中所有依赖打包到一个文件中，这样可以减少浏览器在加载页面时候的请求数量，提高页面加载速度，但是我们也可以在vite.config中自行配置build选项来处理vite的打包，
//               例如将node_modules按模块打包，这样实现我们需要什么就加载什么，不用一次把整个依赖包加载出来；
//            4、vite将生成的构建文件存放在node_modules的.vite文件夹中，这些文件都是优化处理后的es模块，可以直接被浏览器加载执行；
//            5、下一次启动开发服务器时，vite会检查依赖是否变化，如果没有变化就直接取缓存中的依赖，如果变化了采用增量预构建方式，将变化的内容重新预构建；
//               在比如optimizeDeps 的includes这种关键配置变化时、.vite缓存目录被删除时、依赖结构变动较大时等情况还是会采用全量预构建。
//               