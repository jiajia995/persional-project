// 组件库相关问题

// 1、多包架构Monorepo
//      定义：
//          多包架构是一种项目管理和代码组织方式，它将多个相关的包或模块集中放在同一个代码仓库中进行管理，而不是为每个包单独创建一个仓库。在多包架构中，各个包
//      虽然有相对独立的功能，但彼此之间可能存在依赖关系，并且可以共享公共的代码、工具和配置。
//      优点：
//          代码复用和共享：多个包可以方便的共享公共代码、工具函数、类型定义等资源。
//          依赖管理简化：所有的包依赖都在一个仓库中统一管理，减少了因不同包使用不同版本依赖而导致的冲突问题，可以一次性更新所有包的依赖，确保版本的一致性；
//          开发效率提升：可以在一个仓库中同时开发和测试多个相关的包，修改了一个包，可以立即在其他应用的包中看到修改的效果；
//          一致性保证：通过共享配置文件，保证所有包遵循统一代码风格、构建流程、部署策略等；
//          便于团队协作：可以清晰看到各个包之间的依赖关系，有利于项目团队管理和协调；
//      缺点：
//         仓库规模和复杂度：包的数量增加，仓库规模和复杂度也会相应增大；
//         依赖循环问题：多个包可能会出现依赖循环问题，比如包A依赖包B，包B又依赖包A；
//         权限管理和发布问题：需要惊喜管理每个包的访问权限和发布权限，确保只有授权人员可以修改和发布；
//         性能问题：多个包都在同一个仓库，构建和测试可能会涉及更多代码和依赖，影响开发效率；
// 2、Monorepo与pnpm、Workspaces的关系
//    Monorepo:
//        Monorepo是一种开发策略，即多个项目、模块或组件代码存储在同一代码仓库中；
//    pnpm、Workspaces：
//        pnpm是快速、节省磁盘空间的包管理工具，而workspaces是项目管理模式，pnpm支持workspaces模式；
//        1、pnpm支持使用Workspaces模式，可以在根目录的pnpm-workspace.yaml文件中配置工作区，不同模块和服务可以放在不同工作区，方便统一管理；
//    同时，对于多个项目都依赖的相同包，pnpm在磁盘上只存储一份，通过硬链接方式让各个项目共享，而且各个子项目又都有自己独立的依赖包；
//        2、pnpm采用内容寻址存储机制和硬链接技术，并且具有依赖提升功能，安装依赖时，对于相同的依赖，pnpm只会在硬盘上存储一份，其他子项目再次安装时，
//    直接通过硬链接引入，安装速度很快；并且通过pnpm - lock.yaml文件控制依赖版本，避免版本混乱；
//        3、pnpm的Workspaces功能，可以统一管理版本和发布，并且可以定义全局脚本，统一控制各个工作区的操作；
// 3、现在有项目a和项目b，a项目下有utils和config项目，问a和b位于同一工作区和不同工作区时，在b中分别引用utils和config有什么区别？
//        相同："utils": "workspace:*",都是以这种方式安装引入；
//        不同：
//           1、同一工作区解析和查找依赖效率更高；
//           2、同一工作区中，当utils和config发生变更，b可以及时感知并使用最新依赖；不同工作区可能需要重新安装或者其他操作；
//           3、同一工作区版本管理较不同工作区更简单点。
// 4、npm、yarn、pnpm的区别，为什么多包管理选用pnpm？
//    yarn相比较于npm，解析依赖速度更快一些、安全性更高，并且更适应于单仓库多项目开发；
//    npm相较于yarn，依赖解析速度稍微逊色一点，但是npm包更全面，拥有强大的脚本功能；
//    具体表现：
//        相同点：
//            1、都采用并行方式处理依赖解析和安装，可以同时对多个依赖检查版本和解析，并且在下载时也能同时下载多个包并且安装；
//            2、都采用本地缓存机制，对下载过的包进行本地缓存，如果需要安装的包在缓存中有的话，直接使用缓存包；
//            3、都是用深度优先搜索算法，也就是DFS，会从根依赖开始，递归解析每个依赖的子依赖，直到到达没有子依赖的叶子节点，
//        再回溯到上一节点，继续解析该节点其他依赖，直到所有依赖都被解析完毕，保证构建依赖树完整性。
//            4、在大型项目中会有很多依赖，安装过程中，如果有重复依赖，就全局检查是否有该版本依赖，如果有直接使用该依赖，如果版本不一致，
//        就嵌套安装该版本依赖。
//        不同点：
//            1、yarn和npm在依赖解析安装时都使用确定性算法，但是yarn使用yarn.lock文件，npm使用package-lock.json文件；
//            2、yarn和npm在进行确定性算法解析依赖时：
//                    yarn：采用最小版本优先算法；yarn根据package.json文件，在npm注册表或者其他包源寻找合适的包，对于包版本，会在文件中的版本范围内，
//                          在满足版本范围的多个版本中，优先选择最小版本，来保证稳定性和兼容性；
//                    npm：采用最高可用版本优先算法；npm根据package.json文件，在注册表或者其他包源寻找合适的包，对于包版本，会在合适版本范围内，在
//                          满足包版本范围的多个版本中，优先选择最高版本，来保证项目可以及时用到心功能、性能优化和安全修复；
//            3、在使用确定性算法解析依赖过程中，在一些特殊情况下，yarn会比yarn多进行一些版本验证和解析操作，导致npm解析依赖时间比yarn慢一点；
//               例如：1、手动修改package.json或者package-lock.json文件，导致npm无法确定lock文件中的版本信息是否仍然满足新需求，就会重新根据package.json检查，确保正确性；
//                        而yarn在新版本范围与lock文件中版本不冲突时，尽量使用lock中已有版本信息，不满足时，才会重新解析依赖，并更新lock；
//                    2、如果项目从不同代码仓库克隆，或者团队协作时，不同成员的package-lock.json文件存在差异，npm也会额外检查和验证解析；
//                       而yarn会根据自身版本解析算法，和lock文件中的精确版本信息来安装依赖，只要lock文件本身时有效的，不会因为文件来源不同而额外大规模检查和验证；
//                    3、在切换包源时，npm重新检查依赖保证所有以来都能找到并且可用；而yarn会在新包源直接下载lock文件中版本的依赖，找不到时，才会重新解析找合适版本的包；
//                    4、npm和yarn都支持安全审计功能，在检查到安全漏洞时，yarn注重局部更新和保证lock稳定性，npm会更全面重新解析依赖来寻找合适版本；
//   npm、yarn与pnpm的区别
//       1、npm、yarn虽然采用扁平化安装，但是只是在本项目只有一份，在不同的项目中是相互独立的，所以磁盘中会出现一个版本的依赖有多份情况；
//          pnpm是采用内容寻址存储(CAS)方式来管理依赖，针对相同依赖，磁盘上只会安装一份，通过内容的哈希值来标识，通过硬链接和软链接到全局磁盘内容来通过寻址存储来管理node_modules，
//       可以节省空间也可以提高依赖安装速度；所以pnpm适合用来管理单仓库多包项目，因为不同包会有共享依赖等。
//       2、在pnpm中，会有.pnpm文件夹中，里面都是硬链接访问磁盘中的依赖文件，然后在node_modules中创建软链接对应直接依赖，直接依赖再通过软链接访问.pnpm中的文件；
// 如果直接依赖中又依赖了依赖b，业务代码中引用了b，pnpm会使用软连接将b存在.pnpm中，这样就可以直接使用b；

// 硬链接：
//     文件系统中，硬链接是指通过索引节点来进行连接。Linux系统中，保存在磁盘的文件，不论什么类型都会分配一个编号，称为索引节点号。磁盘中的同一份文件会对应多个不同的文件名，
// 文件名访问磁盘中文件就是通过硬链接形式，多个文件名都对应相同的inode节点，修改任何一个硬链接的文件其他硬链接文件都会变化，删除任何一个硬链接，其他硬链接和磁盘文件不受影响；
// 软链接：
//     软链接类似于快捷方式，它包含一个指向另一个文件或者目录的路径，它本身并不包含文件的实际数据，而是指向实际文件或目录的引用；比如b是硬链接，a指向b，a和b对应不同的inode节点，
// 删除b，对a没有影响，但是a会变成一个空引用的路径；

// 1、独特的优势和特点？有没有研究过竞争对手的产品，从中学到了什么，或者发现了哪些可以改进的地方？
// 2、请描述一下这个配置库的整体架构设计，各个模块之间是如何协作的？
// 3、在架构设计上，你考虑了哪些因素来确保配置库的可扩展性和可维护性？
// 4、如何管理不同环境（开发、测试、生产）下的配置？采用了哪些方法来确保配置的安全性和准确性？
// 5、对于配置的优先级和覆盖规则是如何设计的？例如，环境变量、配置文件和代码中硬编码的配置之间的优先级关系。
// 6、在开发这个配置库时，选择了哪些技术栈和工具？为什么做出这样的选择？
//    ts、node.js
//    node.js：1、node.js使ts能够在服务器端运行。由于vite本身是基于node.js构建的前端构建工具，使用ts可以与vite生态系统无缝集成，方便配置的加载、解析和处理；
//             2、node.js有庞大的npm包生态系统，有大量现成的工具和库可以使用；
//             3、JavaScript 和 Node.js 具有良好的跨平台特性，可以在不同的操作系统（如 Windows、Linux、macOS）上运行，方便开发者在不同环境下进行开发和部署。
// 7、对于依赖管理和打包发布，使用了哪些工具和流程？
//    pnpm：1、pnpm使用硬链接和符号链接来管理依赖项，避免了npm和yarn会出现的依赖重复安装的问题。当多个项目依赖同一个版本的某个包时，pnpm 只会在磁盘上存储一份该包的副本，其他项目通过硬链接或符号链接来引用这个副本。
//             例如，若项目 A 和项目 B 都依赖 lodash@4.17.21，pnpm 仅会在全局存储一份 lodash@4.17.21，项目 A 和 B 以链接方式使用，极大节省了磁盘空间。
//          2、对于配置库开发，可能会依赖大量工具和库，使用 pnpm 能显著降低磁盘占用，尤其在开发机磁盘空间有限或维护多个相关项目时，这种优势更为明显。
//          3、pnpm 采用并行下载和安装依赖项的方式，能同时处理多个包的安装任务，相比串行安装的方式，可大幅缩短安装时间。例如在安装包含多个依赖的配置库时，pnpm 能快速完成安装，提高开发效率。
//          4、pnpm 拥有高效的缓存系统，当再次安装相同版本的包时，可直接从缓存中获取，无需重新下载，进一步加快了安装速度。
//          5、与 npm 和 yarn 默认的扁平依赖结构不同，pnpm 会为每个依赖项创建一个独立的目录结构，确保依赖之间的隔离性。这有助于避免依赖冲突问题，在配置库开发中，能保证各个依赖按预期工作，减少因依赖冲突导致的配置错误或运行时问题。
//          6、pnpm 的 pnpm - lock.yaml 文件会精确记录每个依赖项的版本和来源，保证不同环境下依赖安装的一致性，避免因依赖版本不一致导致的兼容性问题。
//          7、若配置库是一个包含多个子包的 monorepo 项目，pnpm 的工作区功能可以方便地管理这些子包之间的依赖关系。开发者可以在一个仓库中同时开发多个相关的配置模块，并通过工作区快速测试和调试它们之间的交互。
//   rollup：1、vite和webpack在打包时，会额外引入一些包装代码来兼容不同模块系统，打包后的体积没有rollup小和简洁；
//           2、webpack配置比较复杂，他有丰富的插件和加载器，可以处理各种复杂的场景，但是对于配置库这种简单的项目，使用webpack会增加开发和维护成本；
//              而vite主要侧重于服务器的冷启动和热更新能力，所以vite在开发阶段比较有优势，在打包构建时，没有rollup灵活；
//           3、而rollup打包体积小、打包代码适用于各种环境、支持输出多种格式等特性，使得我们最终选择rollup打包。
// 8、请详细介绍一下配置库的核心功能是如何实现的，比如配置的加载、解析和合并。
// 9、在处理复杂配置结构（如嵌套对象、数组）时，采用了什么方法来确保配置的正确性和一致性？
//    配置验证：
//        1、加载配置后，对每个配置项进行数据类型检查；
//        2、验证配置项的值是否在合理范围内；
//        3、设置默认配置。
//    在配置库发版时，会自动给组内发送机器人提醒，告知大家发版版本号和修改内容。
// 10、在配置加载和解析过程中，可能会遇到各种错误，你是如何处理这些错误的？
//     打包失败，但是运维平台没有提示
// 11、有没有实现一些容错机制，以确保在部分配置缺失或错误的情况下，配置库仍然能够正常工作？
//     1、为每个配置项提供默认值；
//     2、配置验证和错误捕获：在加载和使用配置之前，对配置进行验证，检查配置项的数据类型、取值范围等是否符合要求。如果发现配置错误，捕获错误并进行相应的处理，例如记录日志、使用默认值替代错误配置等。
//     3、部分配置缺失处理：当部分配置缺失时，配置库可以根据已有的配置和默认值继续工作。对于缺失的配置项，使用默认值进行填充，确保程序的基本功能不受影响。
//     4、配置回退机制：当某个配置源（如配置文件、环境变量）出现问题时，可以回退到其他配置源或默认配置。例如，如果配置文件无法加载，可以尝试使用环境变量中的配置；
// 如果环境变量也没有提供相应的配置，则使用默认配置。
//     5、日志记录与监控:在配置加载和验证过程中，记录详细的日志信息，包括配置的来源、加载结果、错误信息等。通过日志监控，可以及时发现配置问题，并采取相应的措施进行修复。
// 12、开发者如何在项目中使用这个配置库？请提供一些简单的使用示例。
// 13、配置库是否提供了友好的 API 接口，方便开发者进行配置的读取、修改和保存？
// 14、这个配置库是否可以与其他常用的前端或后端框架（如 React、Vue、Node.js）集成？如果可以，是如何实现的？
//     node.js、vue集成，直接在vite.config等配置文件中引入即可
// 15、在不同的操作系统和 Node.js 版本下，配置库的兼容性如何？是否进行过相关的测试？
//      node.js只适用于高版本，比如16以上，因为安装的vite等依赖版本都是5以上的，低版本node打包会失败。
//      暂时没有做低版本node的兼容，因为代码打包可以直接本地升级node版本，线上打包，运维平台可以选高版本node；
//      对于一些配置比较低的老项目，因为我们本身就打算对依赖作全面升级，所以直接升级到高版本了，直接兼容配置库。
// 16、如何进行配置库的版本管理？版本更新的频率和规则是怎样的？
//     语义化版本号格式为 MAJOR.MINOR.PATCH（主版本号。次版本号。修订号）;
//         1、主版本号（MAJOR）：当进行不兼容的 API 修改时，主版本号递增。例如，对配置库的 API 接口进行了大规模重构，导致原有的使用方式不再适用，就需要增加主版本号；
//         2、次版本号（MINOR）：当以向后兼容的方式添加功能时，次版本号递增。比如，在配置库中新增了一个配置项读取的方法，但不影响原有的 API 使用，此时增加次版本号；
//         3、修订号（PATCH）：当进行向后兼容的错误修复时，修订号递增。若发现配置库在某些特定情况下存在配置读取错误，修复该问题后，增加修订号。
//     为代码打标签：在每次发布新版本时，为代码打标签。例如，当发布版本 1.2.3 时，使用 git tag v1.2.3 为当前代码状态打标签，方便后续查找和回溯特定版本。
//     维护CHANGELOG.md文档，记录每个版本的更新内容；在变更日志中，详细描述每个版本的主要更新点，包括新增功能、修复的问题、不兼容的变更等信息
// 17、在更新配置库时，如何确保不会对现有项目造成兼容性问题？
// 18、对于这个配置库的未来发展，你有哪些功能扩展的计划？
//     灰度发布
// 19、如何根据用户反馈和市场需求，确定功能扩展的优先级？
// 20、如果这个配置库是开源的，你在社区建设方面有哪些计划和举措？
// 21、如何吸引更多的开发者参与到项目的贡献中来？
// 22、为什么把组件库、配置库、utils库使用多包架构统一管理？