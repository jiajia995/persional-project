// 1、    es6中的Class关键字也就是类，实质其实是构造函数的语法糖，主要是为了解决我们传统的面向对象编程实现方式的冗余、不够简洁、规范等问题而产生的；
// 2、    在es5中，我们想要定义一个对象person，首先我们要先定义一个构造函数Person，在函数中定义对象上需要有的属性，在利用原型方式，Person.prototype.introduce=function(){}
//    的方式来定义对象上的方法，最后执行const person = new Person()的方式来完成对象的定义，比较不容易理解，不够直观简洁；
//        但是在es6中，引入关键字Class，我们定义一个对象，可以把属性和方法都集中在一起，更加直观；Class Person{construct(){}, introduce() {}}在构造函数中定义属性，直接在类中定义方法即可；
// 3、每个类都有一个contruct函数，如果我们没有手动定义，就会默认有一个空的construct；
// 4、类中定义方法，有public公有方法、previre私有方法、static静态方法；
//        public：直接在类主体内定义，不需要额外的修饰符，可以被实例对象访问、可以被继承；
//                1、是直接定义在类的原型上的，所以类的所有实例都可以访问，并且类是所有实例都共享原型链，我们可以使用Object.getPrototypeOf(person).introduce来测试；
//                2、可以被子类继承，子类继承了Person后，子类的实例化对象可以访问父类中定义的public方法，并且子类中可以重写父类的public方法；
//        privite：在类主体上定义，通过#名称来声明，#让私有属性有了特殊的访问规则，普通属性可以使用person['name']访问，私有属性不能用这种方式；
//                 1、私有实例字段
//                        1、对于基类，私有实例字段是在构造函数运行之前就完成初始化的，比如在Person类中定义#name='张三'，在construct函数中调用this.#name是可以拿到'张三'的值的，
//                    但是我们可以通过几种方式来修改私有实例字段的值：构造函数中修改、实例对象调用的实例方法中修改
//                        2、对于继承基类的子类，需要先在构造函数中执行super()来调用确保父类的构造函数被执行，super()之后才能访问和操作私有实例字段；
//                           每个类的实例都有自己独立的私有实例字段副本，并且在不同实例之间是相互独立的，我们要访问和修改，只能通过类内部的方法来操作；
//                           私有实例字段不能被子类继承，也就是子类中不能直接访问和修改，但是可以通过父类定义公有方法访问私有属性，子类访问父类的公共方法方式来访问；
//                 2、私有静态字段
//                        1、私有静态字段属于类本身，而不是类的实例，就是说在执行构造函数之前，字段就已经初始化在类上了；
//                        2、只能在类内部被访问，我们可以定义静态方法来间接访问，子类和其他类都不能访问，在子类中直接访问父类的私有静态字段会报错；
//                        3、我们在方法中访问字段时候，使用this会在继承、脱离类执行类中方法中等场景中，导致执行出错；
//                 3、私有实例方法
//                        1、私有实例方法在实例字段被初始化之前就被设置到实例上了，也就是说在实例方法开始创建的时候，我们就可以调用私有实例方法了；
//                        2、私有实例方法不能直接通过实例调用，可以通过实例调用实例方法，在实例方法中调用私有实例方法的方式来间接调用；
//                        3、公有实例方法会被添加到类的prototype上，私有实例方法不会，每个实例都有自己独立的私有实例方法副本
//                 4、私有静态方法
//                        1、私有静态方法在类被解析时候就会被添加到类的构造函数中，他们在类的生命周期早期就被确定和配置好，成为类的一部分，在类加载和初始化阶段就被加载到内存中，以便在需要时
//                    可以被类内部其他方法调用；
//                        2、只能在类内部访问，通过类名来调用，所以经常用于辅助实现类的一些功能，成为类内部的一种工具方法；
//                        3、在静态方法执行环境中，this可能会指向全局对象、类的构造函数或者其他不相关的对象，而不是类本身或类实例，所以可能会出错；
//       static：用于定义类的静态方法和静态属性，静态成员属于类本身，不属于类实例，我们可以通过类名调用来访问，不需要先创建实例。
//               1、静态函数通常是一些比较实用的函数，比如创建或者克隆对象，静态属性比较适合用于缓存、固定配置等不需要跨实例复制的数据。
//               2、静态初始化块：static{ this.data = [] }，主要用于类被加载时候执行一些初始化操作，块内可以访问类的静态属性和方法。
//               3、只能通过类名访问，不能通过类实例；
//               4、在静态方法和静态初始化块中，this指向类本身而不是类实例；
// 5、继承
//        继承就是使用extends从现有的父类继承属性和方法来创建一个子类，在子类中使用super来调用父类的构造函数、方法、属性等。
//        1、子类可以重写父类同名的方法，子类实例中调用该方法时候，调用的是子类中的方法；
//        2、在子类重写的方法中，可以使用super来调用父类的同名方法，来实现在子类中复用父类方法的逻辑；
//        3、也可以用来继承内置对象，比如Array、Map等，来扩展他们的功能；
//        4、在子类的构造函数中，如果使用this，就必须要先调用super，因为super会首先去执行父类的构造函数，在整个过程中会被整个对象的基础部分初始化，其中包括为this所代表的当前对象实例分配的内存空间，
//           初始化从父类继承来的属性等操作，使得this能够被正确定义和初始化，没有调用super之前，this是未定义的；
//        5、父类的public成员都会被继承，无论是公有成员还是static成员，私有成员不会被继承。


// 构造函数
//     

